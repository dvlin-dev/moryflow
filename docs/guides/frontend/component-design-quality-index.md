---
title: 前端组件设计质量索引（拆分与收敛准则）
date: 2026-02-26
scope: frontend, web/pc/mobile
status: active
---

<!--
[INPUT]: React 前端组件复杂度失控问题（大组件、过度拆分、Props drilling）
[OUTPUT]: 可执行的组件设计行为准则 + 审查基线
[POS]: 前端组件代码质量总则（用于后续 Code Review 与重构）

[PROTOCOL]: 本文件变更需同步更新 `docs/index.md` 与 `docs/CLAUDE.md`；若上升为全局约束需同步根 `CLAUDE.md`。
-->

# 前端组件设计质量索引（拆分与收敛准则）

> 目标：避免“大而全组件”与“过度拆分 + Props 穿透”两个极端，保持可维护性与可读性的平衡。  
> 原则：不考虑历史兼容，优先最佳实践与长期可维护性。

## 1. 组件职责边界（必须）

1. 页面组件只做路由级拼装，不承载业务编排细节。
2. 业务编排统一放在 `methods`，组件只触发 `methods.*`。
3. 全局状态统一放在 `zustand store`，`store` 禁止发起网络请求。
4. API 请求统一放在函数式 `api` 模块，禁止 Class ApiClient 与隐式鉴权。
5. 展示组件仅接收渲染必需数据，不直接感知后端协议细节。

## 2. 拆分与合并判定（核心）

### 必须拆分的信号

1. 一个组件同时承担 3 类及以上职责（数据获取、状态编排、交互控制、视图渲染）。
2. JSX 内存在多个独立业务区块，且其中任一区块可单独复用或单测。
3. 同一组件出现明显阶段逻辑（加载/编辑/提交/结果）并互相耦合。
4. 条件分支与嵌套密度过高，阅读需要频繁上下跳转。

### 禁止继续拆分的信号（应合并）

1. 子组件仅做 props 透传（把接收到的 props 原样继续下传）。
2. 新增子组件后没有降低复杂度，只增加跳转和认知成本。
3. 调用方需要维护大量“胶水 props”来拼装组件。
4. 子组件既无复用价值，也无独立业务语义。

## 3. Props 与数据流规范（必须）

1. 禁止跨 2 层以上的 Props drilling。
2. 同一业务对象禁止拆成多段标量 props 传递，优先传领域对象或 ViewModel。
3. 事件回调按“业务意图”命名（如 `onRetryFetch`），禁止泛化命名泛滥。
4. 布尔开关超过 3 个时，改为可判别状态枚举或状态对象。
5. 透传型 props（`...rest`）仅允许在通用 UI 原子组件内使用。

## 4. 状态与副作用规范（必须）

1. 组件本地状态仅保留 UI 临时态（弹窗开关、输入焦点、局部展开）。
2. 跨组件共享状态统一进入 `zustand store`，禁止顶层 Context 透传业务状态。
3. 组件新建与重构阶段，新增共享业务状态禁止使用 React Context；统一落到 `store + methods`。
4. 子组件优先 `useXxxStore(selector)` 就地取数，禁止新增中间“胶水层”仅为透传业务 props。
5. React Context 仅允许用于 Theme/i18n/运行时注入等非业务共享语义。
6. 副作用分层约束：
   - 用户动作触发：放 `methods`。
   - 生命周期同步：放组件 `useEffect`，且每个 effect 只做单一目的。
7. 同一 effect 内禁止混合“请求 + 派生计算 + DOM 操作”三种职责。
8. 业务流程优先显式 `methods`，减少“编排型自定义 Hook”。

### 多状态 UI 渲染规范（必须）

1. 一个组件存在 3 种及以上展示状态时，先收敛成显式状态枚举（如 `ViewState`）。
2. 每个状态必须对应独立 UI 片段（可先同文件函数片段，确认复用后再拆文件）。
3. JSX 中禁止链式三元与嵌套三元；统一使用中间渲染方法（如 `renderContentByState()`）+ `switch` 分发。
4. 状态分发方法只做“状态 -> UI 片段”映射，不在其中发请求或修改外部状态。
5. 二元状态（如按钮 loading 文案）也应优先收敛为命名函数，避免在 JSX 中散落三元表达式。

## 5. 推荐目录形态

```text
FeatureX/
├── FeatureX.tsx
├── components/
├── hooks/
├── methods/
└── view-model/
```

说明：
- `FeatureX.tsx`：容器与拼装层。
- `components/`：纯展示子组件。
- `hooks/`：仅本特性可复用的 UI hook。
- `methods/`：业务编排（跨组件共享时必须）。
- `view-model/`：数据映射与展示模型（需要时再建）。

## 6. 复杂度预算（审查阈值）

1. 单个业务组件建议控制在 200 行以内；超过 300 行必须拆分或说明豁免理由。
2. 同一组件 `useState + useReducer` 合计超过 6 个，必须评估状态收敛。
3. 同一组件 `useEffect` 超过 3 个，必须评估副作用拆分。
4. 单组件 props 超过 12 个，必须评估 ViewModel 或对象化收敛。
5. JSX 条件分支层级超过 3 层，必须重构为显式分支组件。

## 7. 反模式清单（发现即改）

1. `Page -> Section -> Panel -> Item -> Row` 级联透传同一批 props。
2. 在展示组件内直接发请求或拼接 API 参数。
3. 为“复用”而抽象，但只有一个调用点且可读性下降。
4. 父组件持有子组件内部临时状态，造成状态倒挂。
5. 用多个布尔值表达互斥状态（如 `isLoading/isError/isEmpty/isReady` 并存）。

## 8. 审查执行方式（用于后续代码审查）

1. 先判定职责越界：容器、编排、展示是否混在一个文件。
2. 再判定拆分过度：是否存在 Props drilling 与“胶水层”组件。
3. 最后给出重构动作：删除中间层、上提/下沉状态、抽离 ViewModel、合并无语义子组件。
4. 审查输出按严重级别标记：
   - `S1`：影响维护效率或易引入 bug（必须改）。
   - `S2`：结构欠佳但可运行（建议本次改）。
   - `S3`：风格优化项（可延后）。

## 9. 重构原则（零兼容）

1. 不保留 legacy 组件和兼容分支，旧实现直接删除。
2. 优先保证语义清晰与可测试性，不以“代码更短”为目标。
3. 每次重构聚焦一个结构问题，并补齐单测或回归测试。
4. 触达历史业务 Context 时按“触达即迁移”处理，禁止继续扩散用法。
5. 改动完成后同步更新对应目录 `CLAUDE.md` 与文档索引。

---

最后更新：2026-02-26
