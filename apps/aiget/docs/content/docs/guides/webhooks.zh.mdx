---
title: Webhooks
description: 配置 Webhook 接收异步任务通知
---

# Webhooks

Webhook 在长时间运行的操作完成时通知你的应用程序。无需轮询结果，在任务完成时接收 POST 请求。

## 支持的接口

| API | Webhook 支持 |
|-----|--------------|
| Scrape API | 否（同步） |
| Crawl API | 是 |
| Batch Scrape API | 是 |

## 配置

在请求中添加 `webhookUrl`：

```json
{
  "url": "https://example.com",
  "webhookUrl": "https://your-app.com/webhooks/aiget"
}
```

## Webhook 负载

任务完成时，AIGet 向你的 webhook URL 发送 POST 请求。

### 爬取完成

```json
{
  "event": "crawl.completed",
  "data": {
    "id": "crawl_abc123",
    "status": "COMPLETED",
    "startUrl": "https://example.com",
    "totalUrls": 45,
    "completedUrls": 43,
    "failedUrls": 2
  },
  "timestamp": "2024-01-15T10:32:15.000Z"
}
```

### 爬取失败

```json
{
  "event": "crawl.failed",
  "data": {
    "id": "crawl_abc123",
    "status": "FAILED",
    "error": "连续失败次数过多"
  },
  "timestamp": "2024-01-15T10:35:00.000Z"
}
```

### 批量抓取完成

```json
{
  "event": "batch.completed",
  "data": {
    "id": "batch_abc123",
    "status": "COMPLETED",
    "totalUrls": 10,
    "completedUrls": 9,
    "failedUrls": 1
  },
  "timestamp": "2024-01-15T10:30:15.000Z"
}
```

## 处理 Webhook

### Node.js / Express

```javascript
const express = require('express');
const app = express();

app.use(express.json());

app.post('/webhooks/aiget', (req, res) => {
  const { event, data, timestamp } = req.body;

  console.log(`收到 ${event}，时间：${timestamp}`);

  switch (event) {
    case 'crawl.completed':
      handleCrawlComplete(data);
      break;
    case 'batch.completed':
      handleBatchComplete(data);
      break;
    case 'crawl.failed':
    case 'batch.failed':
      handleJobFailed(data);
      break;
  }

  res.status(200).send('OK');
});

async function handleCrawlComplete(data) {
  // 获取完整结果
  const response = await fetch(
    `https://server.aiget.dev/api/v1/crawl/${data.id}`,
    { headers: { 'Authorization': 'Bearer lk_your_api_key' } }
  );
  const result = await response.json();

  // 处理爬取结果
  console.log(`爬取完成：${data.completedUrls} 个页面`);
}
```

### Python / Flask

```python
from flask import Flask, request, jsonify
import requests

app = Flask(__name__)

@app.route('/webhooks/aiget', methods=['POST'])
def handle_webhook():
    payload = request.json
    event = payload['event']
    data = payload['data']

    print(f"收到 {event}: {data['id']}")

    if event == 'crawl.completed':
        handle_crawl_complete(data)
    elif event == 'batch.completed':
        handle_batch_complete(data)

    return jsonify({'status': 'ok'}), 200

def handle_crawl_complete(data):
    # 获取完整结果
    response = requests.get(
        f"https://server.aiget.dev/api/v1/crawl/{data['id']}",
        headers={'Authorization': 'Bearer lk_your_api_key'}
    )
    result = response.json()

    # 处理爬取结果
    print(f"爬取完成：{data['completedUrls']} 个页面")
```

## Webhook 要求

### 端点要求

1. **HTTPS** - Webhook URL 必须使用 HTTPS
2. **快速响应** - 在 30 秒内返回 2xx
3. **幂等** - 优雅处理重复投递

### 响应码

| 状态码 | 含义 |
|--------|------|
| 2xx | 成功 - webhook 已接收 |
| 4xx | 客户端错误 - 不会重试 |
| 5xx | 服务器错误 - 将重试 |

## 重试策略

如果 webhook 端点失败，AIGet 会重试：

| 尝试 | 延迟 |
|------|------|
| 第 1 次重试 | 1 分钟 |
| 第 2 次重试 | 5 分钟 |
| 第 3 次重试 | 30 分钟 |
| 第 4 次重试 | 2 小时 |
| 第 5 次重试 | 24 小时 |

5 次重试后，webhook 标记为失败。

## 最佳实践

1. **立即响应** - 响应后异步处理
2. **验证来源** - 检查请求头/负载
3. **处理重复** - 同一 webhook 可能多次投递
4. **记录所有内容** - 保留调试记录
5. **使用队列** - 将处理卸载到后台 worker

## 示例：完整工作流

```javascript
// 1. 启动带 webhook 的爬取
const crawlResponse = await fetch('https://server.aiget.dev/api/v1/crawl', {
  method: 'POST',
  headers: {
    'Authorization': 'Bearer lk_your_api_key',
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    url: 'https://docs.example.com',
    maxDepth: 3,
    webhookUrl: 'https://your-app.com/webhooks/aiget'
  }),
});

const { data: crawl } = await crawlResponse.json();
console.log(`爬取已启动：${crawl.id}`);

// 2. 你的 webhook 处理器接收结果
// （无需轮询！）
```
